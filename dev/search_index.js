var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RustRegex","category":"page"},{"location":"#RustRegex","page":"Home","title":"RustRegex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RustRegex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RustRegex]","category":"page"},{"location":"#RustRegex.RuIterator","page":"Home","title":"RustRegex.RuIterator","text":"RuIterator(re::RuRegex, str::String; capture = false)\n\nA iterator return each matched substring. By setting capture = true, this is equivalent to eachmatch(re, str).\n\nExample\n\njulia> collect(RustRegex.RuIterator(rure\"\\w+\", \"a b c\"))\n3-element Vector{SubString{String}}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> collect(RustRegex.RuIterator(rure\"\\w+\", \"a b c\"; capture = true))\n3-element Vector{RustRegex.RuRegexMatch}:\n RuRegexMatch(\"a\")\n RuRegexMatch(\"b\")\n RuRegexMatch(\"c\")\n\n\n\n\n\n\n","category":"type"},{"location":"#RustRegex.RuRegex","page":"Home","title":"RustRegex.RuRegex","text":"RuRegex(pattern[, flags]) <: AbstractPattern\n\nA type representing rust regular expression. Some syntax and behavior might be different from PCRE regex.  RuRegex support occursin, findnext, findfirst, findall, replace, split,  startswith, endswith, count, match, and eatchmatch.\n\nSee also: @rure_str\n\n\n\n\n\n","category":"type"},{"location":"#RustRegex.RuRegexMatch","page":"Home","title":"RustRegex.RuRegexMatch","text":"RuRegexMatch\n\nA type representing a single match to a RuRegex found in a string, usually created from match.\n\nThe semantic is the same as RegexMatch.\n\n\n\n\n\n","category":"type"},{"location":"#RustRegex.capture_names-Tuple{RuRegex}","page":"Home","title":"RustRegex.capture_names","text":"capture_names(re::RuRegex) -> Vector{Union{Int, String}}\n\nReturn capture name or index.\n\nExample\n\njulia> RustRegex.capture_names(rure\"(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})\")\n3-element Vector{Union{Int64, String}}:\n \"year\"\n \"month\"\n \"day\"\n\njulia> RustRegex.capture_names(rure\"(?<hour>\\d+):(?<minute>\\d+)(am|pm)?\")\n3-element Vector{Union{Int64, String}}:\n  \"hour\"\n  \"minute\"\n 3\n\n\n\n\n\n\n","category":"method"},{"location":"#RustRegex.has_captures-Tuple{RuRegex}","page":"Home","title":"RustRegex.has_captures","text":"has_captures(re::RuRegex) -> Bool\n\nReturn true if there are any capture groups in the regex.\n\n\n\n\n\n","category":"method"},{"location":"#RustRegex.@rure_str-Tuple{Any, Vararg{Any}}","page":"Home","title":"RustRegex.@rure_str","text":"@rure_str -> RuRegex\n\nConstruct a rust regex, such as rure\"^[a-z]*$\", without interpolation and unescaping (except for  quotation mark \" which still has to be escaped). The regex also accepts one or more flags,  listed after the ending quote:\n\ncase insensitive (i) flag.\nmulti-line matching (m) flag. (^ and $ match new line boundaries.)\nany character (s) flag. (\".\" matches new line.)\ngreedy swap (U) flag. (e.g., + is ungreedy and +? is greedy.)\nignore whitespace (x) flag.\nUnicode (u) flag. (default flag)\n\nSee also: RuRegex\n\n\n\n\n\n","category":"macro"}]
}
